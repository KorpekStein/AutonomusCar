#include <AFMotor.h>
#include <Stepper.h>
#include <math.h>


//----------------PINY---------------



const int Sensor_1_EchoPin = 53;
const int Sensor_1_TrigPin = 52;
const int Sensor_2_EchoPin = 23;
const int Sensor_2_TrigPin = 22;
const int Sensor_3_EchoPin = 24;
const int Sensor_3_TrigPin = 25;
const int Sensor_4_EchoPin = 11;
const int Sensor_4_TrigPin = 12;
const int Sensor_5_EchoPin = 13;
const int Sensor_5_TrigPin = 14;
const int Sensor_6_EchoPin = 15;
const int Sensor_6_TrigPin = 16;

const int Speed_Sensor = 30;


//SPEED MIARA PIN
const int StepsPR = 2048; //steps needed for max turn
Stepper stepper = Stepper(StepsPR, 1,2,3,4);
int StepperStep = 0;

const int ledpin = 26;



/*  MAP TODO MAP ALL SENSORS
 *  Sensor1 - back
 *  Sensor2 - back_left
 *  Sensor3 - front_left
 *  Sensor4 - front
 *  Sensor5 - back_right
 *  Sensor6 - front_right
 */
//-----------Car_properties---------------------------

const float car_length = 30;
const float car_width = 20;
double tire_circumference = 49.5*3.14159265359; //in cm

int speed = 90;
int ms_speed;
//---------------usefull values------------

long time_1;
long time_2;
long time_change;

long steps = 0;
int rps;
//-------------Spot properties----------

float spot_length;
float spot_width;
float spot_width_coeficient = 1.54;

int spot_side; //0 is left, 1 is right
//---------------------------------

AF_DCMotor motor1(3); //left back motor
AF_DCMotor motor2(4); // right back motor



//--------------------------------------

char CarMode = 'C'; // C for control mode, A for parking
char bt='S';

//-------------EXTREMELY IMPORTANT-----------------
int parking_mode = 0; //TODO describe every scenario with appropriate number

/* 0 - no spot found, keep looking
 * 1 - spot found, looking for end
 * 2 - end found, started parking protocol
 * 200 - PARKED
 */

void setup()
{
    Serial.begin(9600);

    MotorsSetup();
    SensorsSetup();
}


void loop()
{

    bt=Serial.read();
    control_type();
    WillHit();

}

//-----------------------CONTROLLING-------------------------


void control_type()
{
    if(bt=='X')
    {
        Stop();
        CarMode='A';
        parking_mode = 0;
        if (GetDistance(Sensor_2_TrigPin, Sensor_2_EchoPin) > GetDistance(Sensor_5_TrigPin, Sensor_5_EchoPin))
        {
            spot_side = 0;
        }
        else
        {
            spot_side = 1;
        }

    }

    if(bt=='x')
    {
        Stop();
        CarMode='C';

    }

    if (CarMode == 'C')
    {
        control();
    }

    if (CarMode == 'A')
    {
        parking();
    }
}

void control()
{
    if(bt=='F')
    {
        forward();
    }

    if(bt=='B')
    {
        backward();
    }

    if(bt=='L')
    {
        left(128);
    }

    if(bt=='R')
    {
        right(128);
    }

    if(bt=='S')
    {
        Stop();
    }

}


//----------------MOTORS--------------
void MotorsSetup()
{
    motor1.setSpeed(speed);
    motor2.setSpeed(speed);
    Stop();

    stepper.setSpeed(10);


}
void forward()
{
    motor1.run(FORWARD);
    motor2.run(FORWARD);

}

void backward()
{
    motor1.run(BACKWARD);
    motor2.run(BACKWARD);

}

void left(int turn)
{
    if (StepperStep-turn >= -max_turn)
    {
        stepper.step(turn, BACKWARD, SINGLE);
        StepperStep -= turn;
    }

}

void right(int turn)
{
    if (StepperStep+turn <= max_turn)
    {
        stepper.step(turn, FORWARD, SINGLE);
        StepperStep += turn;
    }
}


void Stop()
{
    motor1.run(RELEASE);
    motor2.run(RELEASE);

}


void WillHit()
{
    float front_scan = GetDistance(Sensor_4_TrigPin, Sensor_4_EchoPin);
    if(front_scan < 5) Stop();

}





//--------------------------------SENSORS-----------------------------------------------
void SensorsSetup()
{

    pinMode(Sensor_1_TrigPin, OUTPUT);
    pinMode(Sensor_1_EchoPin, INPUT);

    pinMode(Sensor_2_TrigPin, OUTPUT);
    pinMode(Sensor_2_EchoPin, INPUT);

    pinMode(Sensor_3_TrigPin, OUTPUT);
    pinMode(Sensor_3_EchoPin, INPUT);


    pinMode(Sensor_4_TrigPin, OUTPUT);
    pinMode(Sensor_4_EchoPin, INPUT);

    pinMode(Sensor_5_TrigPin, OUTPUT);
    pinMode(Sensor_5_EchoPin, INPUT);

    pinMode(Sensor_6_TrigPin, OUTPUT);
    pinMode(Sensor_6_EchoPin, INPUT);

    pinMode(Speed_Sensor, INPUT_PULLUP);

}

float GetDistance(int TrigPin, int EchoPin)
{
    float distance,duration;

    digitalWrite(TrigPin, LOW);
    delayMicroseconds(2);
    digitalWrite(TrigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(TrigPin, LOW);
    duration = pulseIn(EchoPin, HIGH);
    distance = duration * 0.034 / 2;

    return distance;
}


void parking()
{
    scan_for_parking();
    //TODO implement parking scan
}

void scan_for_parking()
{


    if(digitalRead(Speed_Sensor))
    {
        steps++;
        while(digitalRead(Speed_Sensor));
    }

    float front_side_scan;
    float back_side_scan;



    //--------------for left side-------------


    if (spot_side == 1)
    {
        back_side_scan = GetDistance(Sensor_2_TrigPin, Sensor_2_EchoPin);
        front_side_scan = GetDistance(Sensor_3_TrigPin, Sensor_3_EchoPin);
    }

    else
    {

        back_side_scan = GetDistance(Sensor_5_TrigPin, Sensor_5_EchoPin);
        front_side_scan = GetDistance(Sensor_6_TrigPin, Sensor_6_EchoPin);
    }


    float change = front_side_scan - back_side_scan;


    if(parking_mode == 200)
    {

        blink(1);
        Stop();
        return;

    }


    if (change > car_width && parking_mode == 0) //szuka roznicy pomiedzy przednim i tylnim
    {


        time_1 = millis();
        steps = 0;

        spot_side = 0;
        digitalWrite(ledpin, HIGH);
        spot_length = change;
        parking_mode = 1;

        //TODO start clock so we can measure spot length


    }


    if (parking_mode==1 && back_side_scan < car_width && front_side_scan < car_width) // jak wie ze ma rownolegle to podjezdza do konca (bez liczenia dystansu narazie)
    {


        Stop();

        time_2 = millis();
        time_change = time_2-time_1;

        rps = (steps/20)/time_change;
        ms_speed = rps*tire_circumference;

        //now whether we want car write n cm we need to: ride() delay(n second)

        spot_width = steps/20*tire_circumference - car_length;


        blink(5);
        delay(2000);



        //TODO check conditions whether do park parallel or vertical
        if(spot_length > car_length && spot_width > car_width)
        {
            vertical_parking();
        }

        else if(spot_length > car_width && spot_width*spot_width_coeficient > car_length)
        {
            parallel_parking();
        }

        else
        {
            parking_mode = 0;
            spot_width = 0;
            spot_length = 0;

            return;
        }



        parking_mode = 200;
        return;

    }
    else
    {
        forward();


    }
}


void parallel_parking()
{
    //Funkcje do parkowania uzaleznione od wymiarow (formulka)

    if (spot_side == 0)
    {
        left(512);
    }
    else
    {
        right(512);
    }

    backward();
    delay(1000); // ride n millis
    Stop();

    if (spot_side == 1)
    {
        left(1024);
    }

    else
    {
        right(1024);
    }

    backward();
    delay(1000); // ride n millis
    Stop();


    float back_scan;
    float front_scan;



    if (front_scan > back_scan)
    {
        for(;;)
        {
            forward();
            if (abs(front_scan - back_scan) < 4) break;
        }

    }
    else
    {
        for(;;)
        {
            backward();
            if (abs(front_scan - back_scan) < 4) break;
        }

    }


    Stop();
    left(480);
    parking_mode = 200;
    return;

}
void vertical_parking()
{

    left(512);
    forward();
    delay(1569); // ride n millis
    Stop();
    right(512);


    float back_scan;

      for(;;)
      {
          backward();
          back_scan = GetDistance(Sensor_1_TrigPin,Sensor_1_EchoPin);
          if(back_scan <4) break;
      }
  
  
      Stop();
      parking_mode = 200;
      return;

}

void blink(int n)
{
    for(int i=0;i<n;i++)
    {
        digitalWrite(ledpin, LOW);
        delay(500);
        digitalWrite(ledpin, HIGH);
        delay(500);
        digitalWrite(ledpin, LOW);
    }
}
